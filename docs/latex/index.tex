\hypertarget{index_introduction}{}\section{Introduction}\label{index_introduction}
F\+X pedals are an extremely popular industry, and as the performance of embedded devices becomes better and better, digital F\+X pedals are becoming increasingly popular. Most early F\+X pedals were analog, and many guitarists criticized digital pedals as sounding more \char`\"{}artificial\char`\"{} and \char`\"{}detached\char`\"{}. However, the latest digital pedals produce F\+X that are currently impossible with analog circuits, and the sound quality of digital pedals is drastically improving. The goal of this project was to create a basic F\+X pedal using the Raspberry Pi and a Tiva C. The included F\+X are very simple, but serve as a proof of concept and demonstrate the power of the Raspberry Pi. More advanced F\+X could be produced if a dedicated D\+S\+P chip were used.\hypertarget{index_hardware}{}\section{Hardware}\label{index_hardware}
The pedal is built on a Raspberry Pi and uses a Tiva C for its user interface. On top of the Raspberry Pi sits a Wolfson audio card \mbox{[}1\mbox{]} with 1/8" input and output jacks. The Tiva C is hooked up to the Raspberry Pi's J8 header, which is used for serial interfaces. Pins P\+B0 (Rx) and P\+B1 (Tx) communicate over U\+A\+R\+T with the Tx and Rx pins on the Raspberry Pi. The Tiva C uses 2 buttons (S\+W1 and S\+W2) to capture user input and send the appropriate data to the Pi.\hypertarget{index_software}{}\section{Software}\label{index_software}
The Raspberry Pi is running a distribution of Raspbian issued by Wolfson \mbox{[}1\mbox{]}. This distribution contains the drivers that register the sound card as an A\+L\+S\+A device. A\+L\+S\+A is a framework for registering audio devices on a Linux computer that provides a common interface for reading and writing data to them \mbox{[}2\mbox{]}. On top of the A\+L\+S\+A library, the J\+A\+C\+K Audio Connection Kit \mbox{[}3\mbox{]} provides an even more uniform A\+P\+I for communicating with the card. Once a J\+A\+C\+K server is running, the user can select a frame size to balance computational requirements with latency. Every time a frame is received, a process function is called. The developer has access to a pointer to all of the samples in the frame, and can choose to do whatever he or she wants with these samples and then copies them to an output port.\hypertarget{index_uart}{}\section{U\+A\+R\+T Controller}\label{index_uart}
The user interface is controlled by a Tiva C. The Tiva C is connected to the Raspberry Pi over U\+A\+R\+T. The Raspberry Pi reads the serial port to which the Tiva C sends U\+A\+R\+T data on a separate thread from the F\+X processor, in order to maintain uninterrupted, real-\/time audio processing.

The Tiva C has two buttons. The left button is used to cycle through the different F\+X, which are covered in the \hyperlink{index_fx}{F\+X Processor} section. The second button is used as a tap tempo. This is a commonly used control in F\+X pedals. The user can tap the button at the speed he/she wants the delay to occur. The controller will attempt to match the echo rate to the exact rate at which the button was pressed. Some rounding will occur due to the frame size, but this difference is usually unnoticeable. The controller will consider up to 4 most recent taps to calculate the tempo. If the button has not been pressed for more than 2 seconds, the tap tempo will start fresh.\hypertarget{index_delay}{}\section{Delay Buffer}\label{index_delay}
Delay (or echo) is a common effect that guitarists use to create a repeated decaying echo of whatever they play. The delay effect creates an ambient sound that can really enhance a particular part of a song or solo. There are three main parameters that can change the way a delay sounds.


\begin{DoxyItemize}
\item Mix (or level) -\/ determines how loud the delay is compared to the dry signal.
\item Decay -\/ determines how quickly the signal will decay (or how many times it will repat)
\item Delay (or tempo) -\/ determines the duration of time that passes before the signal repeats
\end{DoxyItemize}

Adjusting these three parameters can create a wide variety of types of delay. A long delay with a fast decay rate can make it sound like two guitarists are playing the same song, but one of them is following the other. A short delay time with a medium decay rate can create a reverberation which is described in the \hyperlink{index_reverb}{reverb} section below. A long decay rate with a medium delay time and a low level can create an ambient background noise that sounds like a blend of all of the notes the guitarist is playing. There are several things guitarists can do with the delay effect, which is why it is one of the most popular effects out there. The delay effect in this project allows for other F\+X (described in the \hyperlink{index_fx}{F\+X Processor} section below) to be applied to the signal when it is repeated. The dry signal comes through clean, but the echo'd signals will have F\+X applied to them. Doing so can produce some unique sounds depending on how the guitar is played.\hypertarget{index_fx}{}\section{F\+X Processor}\label{index_fx}
The F\+X Processor is responsible for processing audio on a sample by sample basis. The class defines one function, {\ttfamily process}, which processes audio on a sample-\/by-\/sample basis. The F\+X processing logic was separated from the delay buffer so that it can be used independently of the delay if desired. The following sections explain which F\+X the class is capable of processing.\hypertarget{index_overdrive}{}\subsection{Overdrive}\label{index_overdrive}
Overdrive is a classic effect used to simulate tubes on an amplifier reaching their limit of amplification. This caused the tubes to round off the higher end of the audio coming through. The rounding causes slight distortion in the signal. The algorithm in this project uses a formula found in \mbox{[}4\mbox{]}. The equation is\+:

$x=\frac{(1+k)x}{1+k*abs(x)}$ \par
 $k=\frac{2a}{1-a}$ \par
 $a=sin(\frac{drive+.01}{1.01}\frac{\pi}{2})$

Where $x$ is the sample, and $drive$ is a value between 0 and 1, specifying how much overdrive is desired.

This algorith differs from hard distortion, which is described below.\hypertarget{index_distortion}{}\subsection{Distortion}\label{index_distortion}
Distortion is similar to overdrive, but generally has a harsher sound than overdrive. There are many different types of distortions, and they are generally made with analog circuits, but a simple algorithm is to simply amplify the signal and clip it. In this class, we multiply the signal (whose range is generally between -\/0.\+2 and 0.\+2) by a number from 1 to 5, and clip it at 0.\+2.\hypertarget{index_tremolo}{}\subsection{Tremolo}\label{index_tremolo}
Tremolo is a technique used by instrumentalists where a single note was repeatedly picked, bowed, or played very quickly. The tremolo effect produces a similar sound on a sustained note by repeatedly cutting and restoring the volume of the output. This allows a player to simply hold a note and get the effect of tremolo without having to perform the technique.\hypertarget{index_reverb}{}\subsection{Reverb}\label{index_reverb}
Reverberation is a phenomenon know to occur in large rooms without much dampening (i.\+e. hard floors and walls). The phenomenon is observed when a loud sound occurs and bounces off the many surfaces in the room creating an echo. Usually, the sound will reach different surfaces at different times, creating a layered echoing effect that differs from delay. The effect was originally recreated by placing an amplifier in a large, undamped room, and recording the natural effect in that room. Afterwards, reverb units were placed in some amplifiers, which consisted of a spring that would vibrate as sound came through the amplifier \mbox{[}5\mbox{]}. A very simple digital reverb effect was created in cartoons by simply producing an echo with a very short repeat delay. That is the effect used in this class's reverb algorithm.\hypertarget{index_wah}{}\subsection{Wah}\label{index_wah}
A wah effect simulates the natural filter that occurs from someones lips when they say the word \char`\"{}\+W\+A\+H\char`\"{}. The mouth can be thought of as a moving bandpass filter which sweeps from low to high frequency. In this class's wah algorithm, a moving bandpass filter is generated using the following equations\+:

$y_l(n) = F_1y_b(n) + y_l(n-1)$ \par
 $y_b(n) = F_1y_h(n) + y_b(n-1)$ \par
 $y_h(n) = x(n) - y_l(n-1) - Q_1y_b(n-1)$ \par
 $F_1 = 2sin(\pi \frac{f_c}{f_s})$

where $Q_1$ determines the size of the pass band and is chosen to be 0.\+1 here \mbox{[}6\mbox{]}.


\begin{DoxyEnumerate}
\item \href{http://www.element14.com/community/community/raspberry-pi/raspberry-pi-accessories/wolfson_pi}{\tt http\+://www.\+element14.\+com/community/community/raspberry-\/pi/raspberry-\/pi-\/accessories/wolfson\+\_\+pi}
\item \href{http://www.alsa-project.org/main/index.php/Main_Page}{\tt http\+://www.\+alsa-\/project.\+org/main/index.\+php/\+Main\+\_\+\+Page}
\item \href{http://jackaudio.org}{\tt http\+://jackaudio.\+org}
\item \href{http://ses.library.usyd.edu.au/bitstream/2123/7624/2/DESC9115_DAS_Assign02_310106370.pdf}{\tt http\+://ses.\+library.\+usyd.\+edu.\+au/bitstream/2123/7624/2/\+D\+E\+S\+C9115\+\_\+\+D\+A\+S\+\_\+\+Assign02\+\_\+310106370.\+pdf}
\item \href{http://www.soundonsound.com/sos/Oct01/articles/advancedreverb1.asp}{\tt http\+://www.\+soundonsound.\+com/sos/\+Oct01/articles/advancedreverb1.\+asp}
\item \href{http://www.cs.cf.ac.uk/Dave/CM0268/PDF/10_CM0268_Audio_FX.pdf}{\tt http\+://www.\+cs.\+cf.\+ac.\+uk/\+Dave/\+C\+M0268/\+P\+D\+F/10\+\_\+\+C\+M0268\+\_\+\+Audio\+\_\+\+F\+X.\+pdf} 
\end{DoxyEnumerate}